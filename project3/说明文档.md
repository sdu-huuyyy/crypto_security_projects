
### **1. 实验原理**

本次实验任务是利用**零知识证明（ZKP）** 技术，通过 **Circom** 和 **Groth16** 算法来验证一个哈希计算。电路的作用是让证明者（Prover）在不泄露隐私输入（哈希原像）的情况下，向验证者（Verifier）证明他知道一组原像，这组原像经过 Poseidon2 哈希计算后，其结果等于一个公开的哈希值。

这个过程可以理解为：

1.  **证明者（Prover）** 知道一个秘密值 $x$。
2.  他向 **验证者（Verifier）** 公布一个值 $y$，并声称 $y = \text{Poseidon2}(x)$。
3.  证明者生成一个 **零知识证明**，证明这个等式成立，而不需要透露 $x$ 的具体值。
4.  验证者收到证明后，可以快速验证其有效性，从而确信证明者确实知道 $x$。

---

### **2. 数学推导**

Circom 电路最终会被编译成一个巨大的**算术电路**，这个电路可以用一系列**多项式方程**来表示。Groth16 算法就是在这组多项式方程上工作的，可以被数学化地描述为一个多项式方程的集合，其中：

* **变量**：包括公开变量（`public_hash`）和私有变量（`secret_preimage`）。
* **约束（Constraints）**：电路中的每个等式（例如 `a === b` 或 `c <== d`）都会被转换为一个**二次方程**约束。

Poseidon2 哈希算法本身由一系列复杂的数学运算组成，这些运算在 Circom 中被分解为更简单的算术操作。其核心步骤包括：

1.  **加常数（Add Round Constants）**：将一个常数向量加到状态向量上。这在电路中表示为：
    $state[i]' = state[i] + C[i]$
2.  **S-box**：对状态中的每个元素进行非线性变换。对于你的参数，S-box 指数 $d=5$，这意味着每个元素都进行五次方运算：
    $state[i]'' = state[i]'^5$
    这个操作在电路中对应一个二次约束：`state[i] * state[i] * state[i] * state[i] * state[i]`。
3.  **矩阵乘法（MDS Matrix Multiplication）**：将状态向量与一个 MDS 矩阵相乘。这在电路中表示为：
    $state_{new}[i] = \sum_{j=0}^{t-1} M_{ij} \cdot state[j]''$
    这个操作被拆解成一系列加法和乘法约束。


最终，所有这些约束共同形成了一个复杂的算术电路。

Groth16 算法的工作就是证明存在一组 `secret_preimage` 的值，使得这个庞大的算术电路中的所有约束都同时成立。

---

### **3. 代码思路**

#### **a) 原始代码思路**

* **功能**：计算一个 Poseidon2 哈希值。
* **输入**：一个私有输入数组 `privateInput`。
* **实现**：实例化一个 `Poseidon` 组件，将 `privateInput` 数组连接到该组件的输入 `poseidon.inputs`。
* **输出**：直接将组件的输出 `poseidon.out` 赋值给电路的公开输出 `hashOutput`。
* **核心**：这是一个**计算型**的电路，它只负责计算哈希值。如果要用它来做证明，还需要在外部用一个断言来验证。

#### **b) 改进后代码思路**

* **功能**：批量验证哈希值。
* **结构**：采用**模板嵌套**的方式，将哈希计算和哈希验证两个逻辑分开。
    * **`Poseidon2SingleHash`** 子模板：
        * **输入**：一个私有原像数组 `in_preimage`。
        * **核心**：实例化一个 `Poseidon` 组件，将 `in_preimage` 传入，并将计算结果通过 `out_hash` 传出。这个子模板只负责计算，不进行验证。
    * **`BatchPoseidon2Verifier`** 主模板：
        * **输入**：一个**公开哈希数组** `public_hashes` 和一个**私有原像二维数组** `secret_preimages`。
        * **核心**：**实例化多个 `Poseidon2SingleHash` 组件**。通过循环将 `secret_preimages` 的每一行连接到不同的子组件，然后使用**断言 `===`** 将每个子组件的输出与 `public_hashes` 中的对应元素进行比较。
* **核心**：通过使用 `===` 断言，将“哈希计算”和“哈希验证”这两个步骤融入了同一个电路中。这个结构使得电路的功能更加明确，也更符合零知识证明中**“证明等式成立”**的本质。

