# SM4算法优化

## 实验目的

本实验旨在深入理解中国商用密码算法SM4的实现原理，并通过多种优化技术提升其软件执行效率。实验将实现基础版本的SM4算法，并逐步应用T-table、AES-NI和SIMD指令集等优化技术。

## 实验原理

### SM4算法基础
SM4是一种对称分组密码算法，具有以下核心特性：
- **分组大小**：128位
- **密钥长度**：128位
- **轮数**：32轮

#### 加密过程
1. **输入处理**：将128位明文分为4个32位字(X₀, X₁, X₂, X₃)
2. **32轮迭代**：
   ```math
   X_{i+4} = X_i ⊕ L(τ(X_{i+1} ⊕ X_{i+2} ⊕ X_{i+3} ⊕ rk_i))
   ```
   其中：
   - τ: 非线性变换（S盒应用）
   - L: 线性变换
   - rk_i: 轮密钥
3. **输出处理**：最终输出(X₃₅, X₃₄, X₃₃, X₃₂)

#### 密钥扩展
1. 初始密钥MK与系统参数异或
2. 32轮迭代生成轮密钥：
   ```math
   rk_i = K_i ⊕ L'(τ(K_{i+1} ⊕ K_{i+2} ⊕ K_{i+3} ⊕ CK_i))
   ```
   其中L'是专用线性变换

## 实验方案

### 1. 基础实现
- **实现方式**：直接按照算法描述实现
- **核心操作**：
  - 逐字节S盒替换
  - 线性变换L中的循环移位操作
- **特点**：
  - 代码直观易理解
  - 执行效率较低（大量逐字节操作）

### 2. T-table优化
- **优化原理**：预计算S盒和线性变换L的复合结果
  ```math
  T_table[x] = L(τ(x))
  ```
- **实现改进**：
  - 将轮函数简化为：
    ```c
    X[i+4] = X[i] ^ 
              T_table[(temp >> 24)] ^ 
              rotate_left(T_table[(temp >> 16) & 0xFF], 8) ^
              rotate_left(T_table[(temp >> 8) & 0xFF], 16) ^
              rotate_left(T_table[temp & 0xFF], 24);
    ```
- **优势**：
  - 减少S盒查找次数
  - 避免重复计算线性变换
  - 内存访问局部性优化

### 3. AES-NI优化
- **优化原理**：利用Intel AES指令集加速S盒计算
- **关键技术**：
  1. **S盒加速**：
     ```c
     __m128i sm4_sbox_aesni(__m128i x) {
         // 使用AESNI指令实现S盒仿射变换
         x = _mm_shuffle_epi8(x, MASK);
         x = MulMatrix(x, higherMask, lowerMask);
         x = _mm_xor_si128(x, _mm_set1_epi8(0x63));
         x = _mm_aesenclast_si128(x, _mm_setzero_si128());
         // ...后续处理
     }
     ```
  2. **4块并行处理**：
     ```c
     void sm4_encrypt_4blocks_aesni(const uint8_t input[64], ...) {
         // 加载4个块到SIMD寄存器
         Tmp[0] = _mm_loadu_si128((const __m128i*)input);
         // ...加载其他3块
         
         // 并行处理
         for (int i = 0; i < 32; i++) {
             __m128i k = _mm_set1_epi32(rk[i]);
             Tmp[0] = MM_XOR4(X[1], X[2], X[3], k);
             Tmp[0] = sm4_sbox_aesni(Tmp[0]);
             // ...线性变换
         }
     }
     ```
- **优势**：
  - 利用CPU硬件加速S盒计算
  - SIMD指令并行处理4个数据块
  - 显著提升吞吐量

### 4. SM4-GCM实现
- **GCM模式原理**：
  - 认证加密模式（Galois/Counter Mode）
  - 结合计数器模式加密和Galois域认证
- **关键组件**：
  1. **计数器模式加密**：
     ```math
     C_i = P_i ⊕ E_K(CTR + i)
     ```
  2. **GHASH认证**：
     ```math
     Auth = (H^m ⊕ C_1H^{m-1} ⊕ ... ⊕ C_mH) ⊕ E_K(CTR_0)
     ```
     H为SM4加密全0块的结果
- **优化策略**：
  - 使用并行化的SM4实现（如AES-NI优化版）
  - 预计算H的幂次表
  - 使用PCLMULQDQ指令加速GF(2^128)乘法

## 实验环境

- **硬件**：x86_64架构CPU（支持AES-NI指令集）
- **编译器**：GCC 9.4+ / Clang 12+
- **编译选项**：`-O3 -maes -mpclmul -mavx2`
- **测试数据**：随机生成的100组128位明文

## 性能评估

| 实现方式       | 加密速度(cycles/block) | 解密速度(cycles/block) | 吞吐量(MB/s) |
|----------------|------------------------|------------------------|--------------|
| 基础实现       | 850.32                 | 845.91                 | 47.21        |
| T-table优化    | 220.67                 | 218.94                 | 181.84       |
| AES-NI(4块并行)| 55.18                  | 54.87                  | 724.62       |

## 结论

1. **优化效果显著**：从基础实现到AES-NI优化，性能提升超过15倍
2. **指令集优势**：AES-NI和SIMD指令对分组密码优化效果最佳
3. **内存与计算权衡**：T-table优化通过空间换时间提升效率
4. **并行化收益**：4块并行处理充分利用现代CPU的SIMD能力
