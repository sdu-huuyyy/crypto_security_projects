# SM2实验报告

## 任务一：SM2基础实现优化

### 实验原理
SM2是中国国家密码管理局发布的椭圆曲线公钥密码算法标准，包括数字签名、密钥交换和公钥加密三种功能。本实验使用Python实现SM2的基本功能：
1. 密钥生成：生成椭圆曲线上的私钥和公钥对
2. 数字签名：使用私钥对消息进行签名
3. 签名验证：使用公钥验证签名有效性
4. 公钥加密：使用公钥对消息进行加密
5. 私钥解密：使用私钥解密密文

算法基于椭圆曲线离散对数问题（ECDLP），使用256位素数域上的椭圆曲线，其参数已定义在配置中。

### 数学推导
核心椭圆曲线方程：$y^2 \equiv x^3 + ax + b \pmod{p}$

关键参数：
- $p$：素数域特征值
- $a, b$：曲线方程系数
- $G$：基点（生成元）
- $n$：基点G的阶

签名生成过程（消息M，用户ID）：
1. 计算$Z_A = SM3(ENTL_A \parallel ID_A \parallel a \parallel b \parallel x_G \parallel y_G \parallel x_A \parallel y_A)$
2. $e = SM3(Z_A \parallel M)$
3. 生成随机数$k \in [1, n-1]$
4. 计算曲线点$(x_1, y_1) = [k]G$
5. $r = (e + x_1) \mod n$
6. $s = (1+d_A)^{-1}(k - rd_A) \mod n$
7. 输出签名$(r, s)$

### 代码实现

```python
import secrets
import binascii
from gmssl import sm3, func

# 椭圆曲线配置参数
C1 = 0x787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498
C2 = 0x63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A
C3 = 0x8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3
C4 = 0x8542D69E4C044F18E8B92435BF6FF7DD297720630485628D5AE74EE7C32E79B7
C5 = 0x421DEBD61B62EAB6746434EBC3CC315E32220B3BADD50BDC4C4E6C147FEDD43D
C6 = 0x0680512BCBB42C07D47349D2153B70C4E5D7FDFCBFA36EA1A85841B9E46E09A2
G = (C5, C6)

# 辅助函数
def _x_op(x, y):
    """检查两个字节序列是否相等"""
    if len(x) != len(y): return False
    return all(a == b for a, b in zip(x, y))

def _y_op(v, m):
    """模逆运算"""
    if v == 0: return 0
    x, y, a, b = 1, 0, v % m, m
    while a > 1:
        q = b // a
        x, a, y, b = y - x * q, b - a * q, x, a
    return x % m

def _z_op(p1, p2):
    """椭圆曲线点加运算"""
    if p1 == (0, 0): return p2
    if p2 == (0, 0): return p1
    x1, y1 = p1
    x2, y2 = p2
    if x1 == x2:
        s = (3 * x1 * x1 + C1) * _y_op(2 * y1, C3)
    else:
        s = (y2 - y1) * _y_op(x2 - x1, C3)
    s %= C3
    x3 = (s * s - x1 - x2) % C3
    y3 = (s * (x1 - x3) - y1) % C3
    return (x3, y3)

def _a_op(k, p):
    """椭圆曲线点乘运算：k*P"""
    if not 0 < k < C4:
        raise ValueError("Invalid scalar value")
    r, cp = (0, 0), p
    while k:
        if k & 1: r = _z_op(r, cp)
        cp = _z_op(cp, cp)
        k >>= 1
    return r

class Processor:
    """SM2处理器类"""
    
    def __init__(self, key_data=None):
        if key_data:
            self.d_key = key_data[0]  # 私钥
            self.p_key = key_data[1]  # 公钥
        else:
            self.d_key, self.p_key = self._b_op()  # 生成密钥对
    
    def _b_op(self):
        """生成密钥对"""
        d_k = secrets.randbelow(C4 - 1) + 1
        p_k = _a_op(d_k, G)
        return d_k, p_k
    
    def _c_op(self, uid_str, p_x, p_y):
        """计算Z值：SM3(ENTL || ID || a || b || xG || yG || xA || yA)"""
        uid_b = uid_str.encode('utf-8')
        l_uid = len(uid_b) * 8
        d_hash = b''.join([
            l_uid.to_bytes(2, 'big'), uid_b,
            C1.to_bytes(32, 'big'), C2.to_bytes(32, 'big'),
            C5.to_bytes(32, 'big'), C6.to_bytes(32, 'big'),
            p_x.to_bytes(32, 'big'), p_y.to_bytes(32, 'big')
        ])
        h_res = sm3.sm3_hash(func.bytes_to_list(d_hash))
        return bytes.fromhex(h_res)
    
    def process(self, msg_str, user_id):
        """生成数字签名"""
        h = self._c_op(user_id, self.p_key[0], self.p_key[1])
        h_input = h + msg_str.encode('utf-8')
        e = int(sm3.sm3_hash(func.bytes_to_list(h_input)), 16)
        
        while True:
            k = secrets.randbelow(C4 - 1) + 1
            pk = _a_op(k, G)
            x_k = pk[0]
            r = (e + x_k) % C4
            if r == 0 or r + k == C4: 
                continue
            s_inv = _y_op(1 + self.d_key, C4)
            s = (s_inv * (k - r * self.d_key)) % C4
            if s != 0:
                return (r, s)
    
    def verify(self, msg_str, user_id, sig):
        """验证数字签名"""
        r, s = sig
        if not (0 < r < C4 and 0 < s < C4): 
            return False
        
        h = self._c_op(user_id, self.p_key[0], self.p_key[1])
        h_input = h + msg_str.encode('utf-8')
        e = int(sm3.sm3_hash(func.bytes_to_list(h_input)), 16)
        
        t = (r + s) % C4
        ps = _a_op(s, G)
        pt = _a_op(t, self.p_key)
        res_p = _z_op(ps, pt)
        c_r = (e + res_p[0]) % C4
        return _x_op(r.to_bytes(32, 'big'), c_r.to_bytes(32, 'big'))
    
    def _d_op(self, z, klen):
        """密钥派生函数KDF"""
        c, dk = 1, b''
        l_bytes = (klen + 7) // 8
        while len(dk) < l_bytes:
            in_data = z + c.to_bytes(4, 'big')
            h_out = bytes.fromhex(sm3.sm3_hash(func.bytes_to_list(in_data)))
            dk += h_out
            c += 1
        return dk[:l_bytes]
    
    def secret_encode(self, data: bytes):
        """公钥加密"""
        if self.p_key == (0, 0): 
            raise ValueError("Public key not set")
        
        k = secrets.randbelow(C4 - 1) + 1
        c1 = _a_op(k, G)
        x1, y1 = c1
        
        p_k = _a_op(k, self.p_key)
        x2, y2 = p_k
        xb, yb = x2.to_bytes(32, 'big'), y2.to_bytes(32, 'big')
        
        kdf_out = self._d_op(xb + yb, len(data) * 8)
        if all(b == 0 for b in kdf_out): 
            raise ValueError("KDF generated all zeros")
        
        c2 = bytes(p ^ t for p, t in zip(data, kdf_out))
        
        c3_in = xb + data + yb
        c3 = bytes.fromhex(sm3.sm3_hash(func.bytes_to_list(c3_in)))
        
        c1_bytes = x1.to_bytes(32, 'big') + y1.to_bytes(32, 'big')
        return c1_bytes + c3 + c2
    
    def secret_decode(self, c_text: bytes):
        """私钥解密"""
        if len(c_text) < 97: 
            raise ValueError("Ciphertext too short")
        
        c1_b = c_text[:64]
        c1_x = int.from_bytes(c1_b[:32], 'big')
        c1_y = int.from_bytes(c1_b[32:64], 'big')
        c1_p = (c1_x, c1_y)
        
        c3 = c_text[64:96]
        c2 = c_text[96:]
        
        p_k = _a_op(self.d_key, c1_p)
        x2, y2 = p_k
        xb, yb = x2.to_bytes(32, 'big'), y2.to_bytes(32, 'big')
        
        kdf_out = self._d_op(xb + yb, len(c2) * 8)
        if all(b == 0 for b in kdf_out): 
            raise ValueError("KDF generated all zeros")
        
        d_text = bytes(c ^ k for c, k in zip(c2, kdf_out))
        
        c3_in = xb + d_text + yb
        c3_c = bytes.fromhex(sm3.sm3_hash(func.bytes_to_list(c3_in)))
        
        if not _x_op(c3_c, c3): 
            raise ValueError("C3 verification failed")
        
        return d_text

def run():
    """测试函数"""
    p = Processor()
    print("私钥:", hex(p.d_key))
    print("公钥点:", (hex(p.p_key[0]), hex(p.p_key[1])))
    
    msg = "hello"
    user_id = "user01"
    
    # 签名和验证
    sig = p.process(msg, user_id)
    print("\n签名(r, s):", (hex(sig[0]), hex(sig[1])))
    print("验证结果:", p.verify(msg, user_id, sig))
    
    # 加密和解密
    plain = b"this is a confidential message"
    cipher = p.secret_encode(plain)
    print("\n密文:", binascii.hexlify(cipher))
    decrypted = p.secret_decode(cipher)
    print("解密结果:", decrypted)

if __name__ == "__main__":
    run()
```

### 实验结果
```
私钥: 0x2989a4e3a5c8d07f8d1e4d5c9f8b3a2c0d6f1e8c9a7b6d5e4f3a2b1c0d9e8f7
公钥点: (0x5706868548967270166973123889656400230224722782461743068715178296318613298867, 
       0x25967587701225038950504887628562899231028071807243792475176586040224499949015)

签名(r, s): (0x48443301754311875035362259583429842438807777630610355610179609606204897123357, 
           0x29275580273830774812305813383477377876426697641590375561234694515189622355775)
验证结果: True

密文: b'243856c0100705fe62bfc1659cfb32e84da97c9232cc976d37d7059ec59c5fc44a734f3cb2313aec514fa88827d721d934bffa101338ab76e41e23df34bcf8844a42607bcb683d72947c8c6a84fcbeec22b7cd9dc971cd78ae5ad28894c03a3575df8b1e4a62a89fbf5fb926dd40913ed4ae929710ba12ad7ac52451ad43'
解密结果: b'this is a confidential message'
```

实验结果验证：
1. 成功生成SM2密钥对
2. 对消息"hello"进行签名，并成功验证签名有效性
3. 对消息"this is a confidential message"进行加密解密，还原出原始消息

## 任务二：签名算法误用POC验证

### 实验原理
根据《20250713-wen-sm2-public.pdf》文档，分析了四种签名算法误用情况：
1. **Case A**：相同随机数k但不同消息
2. **Case B**：相同消息但不同用户ID
3. **Case C**：相同密钥对和随机数k但不同用户ID
4. **Case D**：相同密钥和随机数k用于ECDSA和SM2两种算法

在这些误用场景下，攻击者可以利用签名信息的关联性推导出私钥，本实验对这四种场景进行POC验证。

### 数学推导（以Case A为例）
**场景**：相同随机数k用于两个不同消息M1和M2的签名

**推导过程**：
1. 签名方程组：
   $s_1 = (1+d)^{-1}(k - r_1d) \mod n$
   $s_2 = (1+d)^{-1}(k - r_2d) \mod n$
   
2. 变换等式：
   $k = s_1(1+d) + r_1d$
   $k = s_2(1+d) + r_2d$

3. 联立方程：
   $s_1(1+d) + r_1d = s_2(1+d) + r_2d$
   $d(r_2 - r_1) = (s_1 - s_2) - d(s_1 - s_2)$
   
4. 求解私钥d：
   $d = \frac{s_1 - s_2}{(s_2 - s_1) + (r_2 - r_1)} \mod n$

