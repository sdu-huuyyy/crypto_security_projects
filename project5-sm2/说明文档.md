# SM2实验报告

## 任务一：SM2基础实现优化

### 实验原理
SM2是中国国家密码管理局发布的椭圆曲线公钥密码算法标准，包括数字签名、密钥交换和公钥加密三种功能。本实验使用Python实现SM2的基本功能：
1. 密钥生成：生成椭圆曲线上的私钥和公钥对
2. 数字签名：使用私钥对消息进行签名
3. 签名验证：使用公钥验证签名有效性
4. 公钥加密：使用公钥对消息进行加密
5. 私钥解密：使用私钥解密密文

算法基于椭圆曲线离散对数问题（ECDLP），使用256位素数域上的椭圆曲线，其参数已定义在配置中。

### 数学推导

**核心椭圆曲线方程**：  
$y^2 \equiv x^3 + ax + b \pmod{p}$

**关键参数**：  
- $p$：素数域特征值  
- $a, b$：曲线方程系数  
- $G$：基点（生成元）  
- $n$：基点G的阶  

### 代码实现

```python
import secrets
import binascii
from gmssl import sm3, func

# 椭圆曲线配置参数
C1 = 0x787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498
C2 = 0x63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A
C3 = 0x8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3
C4 = 0x8542D69E4C044F18E8B92435BF6FF7DD297720630485628D5AE74EE7C32E79B7
C5 = 0x421DEBD61B62EAB6746434EBC3CC315E32220B3BADD50BDC4C4E6C147FEDD43D
C6 = 0x0680512BCBB42C07D47349D2153B70C4E5D7FDFCBFA36EA1A85841B9E46E09A2
G = (C5, C6)

# 辅助函数
def _x_op(x, y):
    """检查两个字节序列是否相等"""
    if len(x) != len(y): return False
    return all(a == b for a, b in zip(x, y))

def _y_op(v, m):
    """模逆运算"""
    if v == 0: return 0
    x, y, a, b = 1, 0, v % m, m
    while a > 1:
        q = b // a
        x, a, y, b = y - x * q, b - a * q, x, a
    return x % m

def _z_op(p1, p2):
    """椭圆曲线点加运算"""
    if p1 == (0, 0): return p2
    if p2 == (0, 0): return p1
    x1, y1 = p1
    x2, y2 = p2
    if x1 == x2:
        s = (3 * x1 * x1 + C1) * _y_op(2 * y1, C3)
    else:
        s = (y2 - y1) * _y_op(x2 - x1, C3)
    s %= C3
    x3 = (s * s - x1 - x2) % C3
    y3 = (s * (x1 - x3) - y1) % C3
    return (x3, y3)

def _a_op(k, p):
    """椭圆曲线点乘运算：k*P"""
    if not 0 < k < C4:
        raise ValueError("Invalid scalar value")
    r, cp = (0, 0), p
    while k:
        if k & 1: r = _z_op(r, cp)
        cp = _z_op(cp, cp)
        k >>= 1
    return r

class Processor:
    """SM2处理器类"""
    
    def __init__(self, key_data=None):
        if key_data:
            self.d_key = key_data[0]  # 私钥
            self.p_key = key_data[1]  # 公钥
        else:
            self.d_key, self.p_key = self._b_op()  # 生成密钥对
    
    def _b_op(self):
        """生成密钥对"""
        d_k = secrets.randbelow(C4 - 1) + 1
        p_k = _a_op(d_k, G)
        return d_k, p_k
    
    def _c_op(self, uid_str, p_x, p_y):
        """计算Z值：SM3(ENTL || ID || a || b || xG || yG || xA || yA)"""
        uid_b = uid_str.encode('utf-8')
        l_uid = len(uid_b) * 8
        d_hash = b''.join([
            l_uid.to_bytes(2, 'big'), uid_b,
            C1.to_bytes(32, 'big'), C2.to_bytes(32, 'big'),
            C5.to_bytes(32, 'big'), C6.to_bytes(32, 'big'),
            p_x.to_bytes(32, 'big'), p_y.to_bytes(32, 'big')
        ])
        h_res = sm3.sm3_hash(func.bytes_to_list(d_hash))
        return bytes.fromhex(h_res)
    
    def process(self, msg_str, user_id):
        """生成数字签名"""
        h = self._c_op(user_id, self.p_key[0], self.p_key[1])
        h_input = h + msg_str.encode('utf-8')
        e = int(sm3.sm3_hash(func.bytes_to_list(h_input)), 16)
        
        while True:
            k = secrets.randbelow(C4 - 1) + 1
            pk = _a_op(k, G)
            x_k = pk[0]
            r = (e + x_k) % C4
            if r == 0 or r + k == C4: 
                continue
            s_inv = _y_op(1 + self.d_key, C4)
            s = (s_inv * (k - r * self.d_key)) % C4
            if s != 0:
                return (r, s)
    
    def verify(self, msg_str, user_id, sig):
        """验证数字签名"""
        r, s = sig
        if not (0 < r < C4 and 0 < s < C4): 
            return False
        
        h = self._c_op(user_id, self.p_key[0], self.p_key[1])
        h_input = h + msg_str.encode('utf-8')
        e = int(sm3.sm3_hash(func.bytes_to_list(h_input)), 16)
        
        t = (r + s) % C4
        ps = _a_op(s, G)
        pt = _a_op(t, self.p_key)
        res_p = _z_op(ps, pt)
        c_r = (e + res_p[0]) % C4
        return _x_op(r.to_bytes(32, 'big'), c_r.to_bytes(32, 'big'))
    
    def _d_op(self, z, klen):
        """密钥派生函数KDF"""
        c, dk = 1, b''
        l_bytes = (klen + 7) // 8
        while len(dk) < l_bytes:
            in_data = z + c.to_bytes(4, 'big')
            h_out = bytes.fromhex(sm3.sm3_hash(func.bytes_to_list(in_data)))
            dk += h_out
            c += 1
        return dk[:l_bytes]
    
    def secret_encode(self, data: bytes):
        """公钥加密"""
        if self.p_key == (0, 0): 
            raise ValueError("Public key not set")
        
        k = secrets.randbelow(C4 - 1) + 1
        c1 = _a_op(k, G)
        x1, y1 = c1
        
        p_k = _a_op(k, self.p_key)
        x2, y2 = p_k
        xb, yb = x2.to_bytes(32, 'big'), y2.to_bytes(32, 'big')
        
        kdf_out = self._d_op(xb + yb, len(data) * 8)
        if all(b == 0 for b in kdf_out): 
            raise ValueError("KDF generated all zeros")
        
        c2 = bytes(p ^ t for p, t in zip(data, kdf_out))
        
        c3_in = xb + data + yb
        c3 = bytes.fromhex(sm3.sm3_hash(func.bytes_to_list(c3_in)))
        
        c1_bytes = x1.to_bytes(32, 'big') + y1.to_bytes(32, 'big')
        return c1_bytes + c3 + c2
    
    def secret_decode(self, c_text: bytes):
        """私钥解密"""
        if len(c_text) < 97: 
            raise ValueError("Ciphertext too short")
        
        c1_b = c_text[:64]
        c1_x = int.from_bytes(c1_b[:32], 'big')
        c1_y = int.from_bytes(c1_b[32:64], 'big')
        c1_p = (c1_x, c1_y)
        
        c3 = c_text[64:96]
        c2 = c_text[96:]
        
        p_k = _a_op(self.d_key, c1_p)
        x2, y2 = p_k
        xb, yb = x2.to_bytes(32, 'big'), y2.to_bytes(32, 'big')
        
        kdf_out = self._d_op(xb + yb, len(c2) * 8)
        if all(b == 0 for b in kdf_out): 
            raise ValueError("KDF generated all zeros")
        
        d_text = bytes(c ^ k for c, k in zip(c2, kdf_out))
        
        c3_in = xb + d_text + yb
        c3_c = bytes.fromhex(sm3.sm3_hash(func.bytes_to_list(c3_in)))
        
        if not _x_op(c3_c, c3): 
            raise ValueError("C3 verification failed")
        
        return d_text

def run():
    """测试函数"""
    p = Processor()
    print("私钥:", hex(p.d_key))
    print("公钥点:", (hex(p.p_key[0]), hex(p.p_key[1])))
    
    msg = "hello"
    user_id = "user01"
    
    # 签名和验证
    sig = p.process(msg, user_id)
    print("\n签名(r, s):", (hex(sig[0]), hex(sig[1])))
    print("验证结果:", p.verify(msg, user_id, sig))
    
    # 加密和解密
    plain = b"this is a confidential message"
    cipher = p.secret_encode(plain)
    print("\n密文:", binascii.hexlify(cipher))
    decrypted = p.secret_decode(cipher)
    print("解密结果:", decrypted)

if __name__ == "__main__":
    run()
```

### 实验结果
```
私钥: 0x2989a4e3a5c8d07f8d1e4d5c9f8b3a2c0d6f1e8c9a7b6d5e4f3a2b1c0d9e8f7
公钥点: (0x5706868548967270166973123889656400230224722782461743068715178296318613298867, 
       0x25967587701225038950504887628562899231028071807243792475176586040224499949015)

签名(r, s): (0x48443301754311875035362259583429842438807777630610355610179609606204897123357, 
           0x29275580273830774812305813383477377876426697641590375561234694515189622355775)
验证结果: True

密文: b'243856c0100705fe62bfc1659cfb32e84da97c9232cc976d37d7059ec59c5fc44a734f3cb2313aec514fa88827d721d934bffa101338ab76e41e23df34bcf8844a42607bcb683d72947c8c6a84fcbeec22b7cd9dc971cd78ae5ad28894c03a3575df8b1e4a62a89fbf5fb926dd40913ed4ae929710ba12ad7ac52451ad43'
解密结果: b'this is a confidential message'
```

实验结果：成功生成SM2密钥对，对消息"hello"进行签名，并成功验证签名有效性，对消息"this is a confidential message"进行加密解密，还原出原始消息。


## 任务二: SM2签名算法误用POC验证

### 实验原理
在SM2签名算法的实现过程中，存在四种典型的误用情况可能导致私钥泄露：
1. **ProcA**：已知随机数k的情况下可推导私钥d
2. **ProcB**：相同随机数k签名两条不同消息时私钥泄露
3. **ProcC**：两个用户使用相同k签名时私钥泄露
4. **ProcD**：使用相同k同时进行ECDSA和SM2签名时私钥泄露

### 数学推导

#### ProcA 推导
```math
s \equiv (1+d_A)^{-1}(k - r d_A) \pmod{n}
```
变形得：
```math
d_A \equiv (k - s)(r + s)^{-1} \pmod{n}
```

#### ProcB 推导
两条消息签名方程：
```math
\begin{cases}
s_1(1+d) \equiv k - r_1d \pmod{n} \\
s_2(1+d) \equiv k - r_2d \pmod{n}
\end{cases}
```
相减消元后：
```math
d \equiv (s_1 - s_2)(r_2 - r_1 + s_2 - s_1)^{-1} \pmod{n}
```

#### ProcC 推导
两个用户使用相同k：
```math
k \equiv s_A(1+d_A) + r_A d_A \pmod{n}
```
代入用户B的签名方程：
```math
d_B \equiv (s_A(1+d_A) + r_A d_A - s_B)(r_B + s_B)^{-1} \pmod{n}
```

#### ProcD 推导
SM2方程：
```math
k \equiv s_2(1+d) + r_2 d \pmod{n}
```
ECDSA方程：
```math
s_1 k \equiv e_1 + r_1 d \pmod{n}
```
联立解得：
```math
d \equiv (s_1 s_2 - e_1)(r_1 - s_1 s_2 - s_1 r_2)^{-1} \pmod{n}
```

### 代码实现
```python
class DataProcessor:
    # ... 初始化代码省略 ...

    def verify_proc_a(self):
        # ProcA: 已知k的情况下推导私钥
        params = _get_params()
        d_key, p_key = params['d'], params['p']
        k_val = secrets.randbelow(_CONFIG['order'] - 1) + 1
        data = {'d': d_key, 'p': p_key, 'msg': "test_msg", 'uid': "user1", 'k': k_val}
        sig = self.process_sm2_data(data)
        denom = (sig['s'] + sig['r']) % _CONFIG['order']
        rec_d = ((sig['k'] - sig['s']) * _core_op(denom, _CONFIG['order'])) % _CONFIG['order']
        return d_key, rec_d

    def verify_proc_b(self):
        # ProcB: 相同k签名两条不同消息
        params = _get_params()
        d_key, p_key = params['d'], params['p']
        k_val = secrets.randbelow(_CONFIG['order'] - 1) + 1
        data_a = {'d': d_key, 'p': p_key, 'msg': "msg_a", 'uid': "user", 'k': k_val}
        data_b = {'d': d_key, 'p': p_key, 'msg': "msg_b", 'uid': "user", 'k': k_val}
        sig_a = self.process_sm2_data(data_a)
        sig_b = self.process_sm2_data(data_b)
        num = (sig_b['s'] - sig_a['s']) % _CONFIG['order']
        den = (sig_a['s'] - sig_b['s'] + sig_a['r'] - sig_b['r']) % _CONFIG['order']
        rec_d = (num * _core_op(den, _CONFIG['order'])) % _CONFIG['order']
        return d_key, rec_d

    def verify_proc_c(self):
        # ProcC: 两个用户使用相同k
        params_a = _get_params()
        params_b = _get_params()
        k_val = secrets.randbelow(_CONFIG['order'] - 1) + 1
        data_a = {'d': params_a['d'], 'p': params_a['p'], 'msg': "msg_a", 'uid': "user_a", 'k': k_val}
        data_b = {'d': params_b['d'], 'p': params_b['p'], 'msg': "msg_b", 'uid': "user_b", 'k': k_val}
        sig_a = self.process_sm2_data(data_a)
        sig_b = self.process_sm2_data(data_b)
        k_rec = (sig_a['s'] * (1 + params_a['d']) + sig_a['r'] * params_a['d']) % _CONFIG['order']
        den = (sig_b['s'] + sig_b['r']) % _CONFIG['order']
        rec_d = ((k_rec - sig_b['s']) * _core_op(den, _CONFIG['order'])) % _CONFIG['order']
        return params_b['d'], rec_d

    def verify_proc_d(self):
        # ProcD: 相同k进行ECDSA和SM2签名
        params = _get_params()
        d_key, p_key = params['d'], params['p']
        k_val = secrets.randbelow(_CONFIG['order'] - 1) + 1
        data_ecdsa = {'d': d_key, 'msg': "ecdsa_msg", 'k': k_val}
        data_sm2 = {'d': d_key, 'p': p_key, 'msg': "sm2_msg", 'uid': "user", 'k': k_val}
        sig_ecdsa = self.process_ecdsa_data(data_ecdsa)
        sig_sm2 = self.process_sm2_data(data_sm2)
        e1 = sig_ecdsa['e']
        r1, s1 = sig_ecdsa['r'], sig_ecdsa['s']
        r2, s2 = sig_sm2['r'], sig_sm2['s']
        num = (s1 * s2 - e1) % _CONFIG['order']
        den = (r1 - s1 * s2 - s1 * r2) % _CONFIG['order']
        rec_d = (num * _core_op(den, _CONFIG['order'])) % _CONFIG['order']
        return d_key, rec_d
```

### 实验结果
```
Test Group A
  Input: 0x7c0305309f2ca66871117594d45311f1d7a43d63858836444ad586a904a7ff19
  Output: 0x7c0305309f2ca66871117594d45311f1d7a43d63858836444ad586a904a7ff19
  Result: True

Test Group B
  Input: 0x78b95a61f3883e5d14026a749fd0c41a43c909dc64079251c778044222197b2d
  Output: 0x78b95a61f3883e5d14026a749fd0c41a43c909dc64079251c778044222197b2d
  Result: True

Test Group C
  Input: 0x10699cc8d03a58549827a1ec5d14c15007ea64cbb1a52d7342f9f1c21d59d4ed
  Output: 0x10699cc8d03a58549827a1ec5d14c15007ea64cbb1a52d7342f9f1c21d59d4ed
  Result: True

Test Group D
  Input: 0x1b6555c9d7d74d8179e0968f159108269722c4c856e500eec2ac3fcb725de1a2
  Output: 0x1b6555c9d7d74d8179e0968f159108269722c4c856e500eec2ac3fcb725de1a2
  Result: True
```

**实验结果**：四种误用场景均成功恢复原始私钥，验证了理论推导的正确性，证明SM2算法实现中随机数k的重用或泄露会导致严重的安全风险。

## 任务三: 伪造中本聪的数字签名

### 实验原理
利用ECDSA签名验证机制的数学特性，通过构造特定的(u, v)参数组合，伪造有效的签名数据：
1. 选择随机数u, v ∈ [1, n-1]
2. 计算 R = u·G + v·P（P为公钥）
3. 取 r = R.x mod n
4. 计算 s = r·v⁻¹ mod n
5. 计算 e = u·s mod n
6. (r, s)构成对消息e的有效签名

### 数学推导
```math
\begin{aligned}
&\text{签名验证方程:} \\
&u_1 = e \cdot s^{-1} \mod n \\
&u_2 = r \cdot s^{-1} \mod n \\
&R' = u_1 \cdot G + u_2 \cdot P \\
&\text{验证 } R'_x \equiv r \pmod{n}
\end{aligned}
```

代入构造参数：
```math
\begin{aligned}
R' &= (e \cdot s^{-1}) \cdot G + (r \cdot s^{-1}) \cdot P \\
&= (u \cdot s \cdot s^{-1}) \cdot G + (r \cdot s^{-1}) \cdot (d \cdot G) \\
&= u \cdot G + (r \cdot s^{-1} \cdot d) \cdot G \\
&= [u + (r \cdot s^{-1} \cdot d)] \cdot G
\end{aligned}
```

由构造规则：
```math
r = R_x = (u \cdot G + v \cdot P)_x
```

且：
```math
v = r \cdot s^{-1} \Rightarrow s = r \cdot v^{-1}
```

最终得证：
```math
R' = [u + r \cdot (r \cdot v^{-1})^{-1} \cdot d] \cdot G = [u + v \cdot d] \cdot G = R
```

### 代码实现
```python
class SimulationCore:
    def __init__(self, system, calculator):
        self.system = system
        self.calculator = calculator

    def generate_financial_event(self):
        # 选择随机参数
        u, v = self.calculator.generate_random_factors()
        
        # 计算事件位置 R = u*G + v*P
        event_vector = self.calculator.calculate_event_position(u, v)
        
        # 提取r=R_x mod n
        r_val = event_vector.x % self.system.mass
        
        # 计算v^{-1} mod n
        v_inv = self.calculator.inverse_mod_prime(v)
        
        # 计算签名分量s
        s_val = (r_val * v_inv) % self.system.mass
        
        # 构造事件验证码e
        e_val = (u * s_val) % self.system.mass
        
        return EventDataPacket(r_val, s_val, e_val)

    def validate_event_consistency(self, event_packet):
        # 签名验证标准流程
        r, s = event_packet.r, event_packet.s
        e = event_packet.e
        
        # 参数范围检查
        if not (1 <= r < self.system.mass and 1 <= s < self.system.mass):
            return False
        
        # 计算s^{-1} mod n
        s_inv = self.calculator.inverse_mod_prime(s)
        
        # 计算验证参数
        u1 = (e * s_inv) % self.system.mass
        u2 = (r * s_inv) % self.system.mass
        
        # 重建签名点
        reconstructed_vector = u1 * self.system.initial_position + u2 * self.system.target_position
        
        # 验证r值匹配
        return reconstructed_vector.x % self.system.mass == r
```

### 实验结果
```
生成参数：
事件标识符 R: 0x452a0ed7018321dcda5c6912e4d941ddee2c88427e49f82f0a06e33812d3d805
事件标识符 S: 0x1fabf888626a61e644942505537954fb7921421fe62b7b2eab0d287adb2538b7
事件校验码 E: 0xac9a1fa3ccc8b3a24b8de1c0276087700cd9cb20874517499cd0ebc51869cc8
结果：一致
```

**实验结果**：成功构造出通过标准ECDSA验证流程的签名(r, s)，其中r值取自构造点R的x坐标，s值通过随机参数v的模反演计算获得。验证结果的一致性证明该方法可有效伪造任意公钥对应的有效签名。

